<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loot Deck Helper</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --surface-alt: #2d2d2d;
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --error-color: #cf6679;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #333;
            --spacing-unit: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            padding: calc(var(--spacing-unit) * 2);
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        h1, h2 {
            margin-bottom: calc(var(--spacing-unit) * 2);
            text-align: center;
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; color: var(--text-secondary); }

        button {
            background-color: var(--primary-color);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            touch-action: manipulation;
        }

        button:hover:not(:disabled) {
            background-color: #a370f7;
        }

        button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--surface-alt);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        button.secondary:hover:not(:disabled) {
            background-color: #3d3d3d;
        }

        button.danger {
            background-color: #cf6679;
            color: #000;
        }

        .section {
            background-color: var(--surface-color);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin-bottom: calc(var(--spacing-unit) * 3);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .hidden { display: none !important; }

        /* Builder Styles */
        .controls-row {
            display: flex;
            gap: var(--spacing-unit);
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: calc(var(--spacing-unit) * 2);
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .template-item {
            background-color: var(--surface-alt);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .template-item label {
            font-weight: 500;
        }

        .template-item input[type="number"] {
            width: 80px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
        }

        .stepper-control {
            display: flex;
            align-items: center;
            gap: 4px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px;
        }

        .stepper-btn {
            background-color: var(--surface-alt);
            color: var(--text-primary);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .stepper-btn:hover:not(:disabled) {
            background-color: var(--primary-color);
            color: var(--bg-color);
        }

        .stepper-btn:disabled {
            background-color: transparent;
            color: var(--text-secondary);
            opacity: 0.3;
            cursor: default;
        }

        .stepper-value {
            width: 40px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 500;
            user-select: none;
            outline: 2px solid transparent;
            border-radius: 2px;
            transition: outline 0.2s;
        }

        .stepper-value:focus {
            outline: 2px solid var(--primary-color);
        }

        .build-stats {
            text-align: center;
            margin-top: calc(var(--spacing-unit) * 2);
            font-size: 1.1rem;
            color: var(--secondary-color);
        }

        /* Active View Styles */
        .draw-controls {
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 2);
            align-items: center;
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .token-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-unit);
        }

        .token-input-group input {
            width: 80px;
            padding: 12px;
            font-size: 1.2rem;
            text-align: center;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
        }

        .big-button {
            width: 100%;
            max-width: 300px;
            padding: 20px;
            font-size: 1.2rem;
        }

        .remaining-pool-display {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: var(--spacing-unit);
        }

        .stats-table-container {
            overflow-x: auto;
            margin-bottom: calc(var(--spacing-unit) * 3);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--surface-alt);
            font-weight: 600;
        }

        tr:last-child td { border-bottom: none; }

        .log-list {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
        }

        .log-entry {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-entry:last-child { border-bottom: none; }

        .log-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-right: var(--spacing-unit);
        }

        .log-content {
            flex-grow: 1;
            text-align: right;
            font-weight: 500;
            color: var(--secondary-color);
        }

        .empty-message {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        .error-message {
            background-color: var(--error-color);
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
            display: none;
        }
        .error-message.visible { display: block; }

        .centered-controls {
            text-align: center;
            margin-top: 24px;
        }

        .centered-controls-alt {
            text-align: center;
            margin-top: 32px;
        }

        .token-label {
            margin-left: 8px;
        }

        .remaining-highlight {
            color: var(--secondary-color);
        }

        .centered-text {
            text-align: center;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>Loot Deck Helper</h1>

    <!-- BUILDER VIEW -->
    <div id="builderView" class="section">
        <h2>Build Loot Pool</h2>

        <div class="controls-row">
            <button class="secondary" id="btnPresetBlank">Clear Counts</button>
            <button class="secondary" id="btnPresetSample">Sample Demo Pool</button>
        </div>

        <div id="templateGrid" class="template-grid">
            <!-- Template Inputs injected here -->
        </div>

        <div class="build-stats">
            Configured Pool Size: <span id="configuredSizeDisplay">0</span>
        </div>

        <div class="centered-controls">
            <button id="btnBuildPool" class="big-button">Build & Start Session</button>
        </div>
    </div>

    <!-- ACTIVE VIEW -->
    <div id="activeView" class="section hidden">
        <h2>Active Session</h2>

        <div id="drawError" class="error-message"></div>

        <div class="draw-controls">
            <!-- Token input removed as per requirements (always draw 1) -->
            <button id="btnDraw" class="big-button">Draw 1 Loot Card</button>
        </div>

        <div class="remaining-pool-display">
            Cards Remaining: <strong id="remainingCountDisplay" class="remaining-highlight">0</strong>
        </div>

        <div class="stats-table-container" role="status" aria-live="polite" aria-label="Remaining loot cards">
            <table>
                <thead>
                    <tr>
                        <th>Card Type</th>
                        <th>Remaining</th>
                    </tr>
                </thead>
                <tbody id="statsTableBody">
                    <!-- Rows injected here -->
                </tbody>
            </table>
        </div>

        <h2>Draw History</h2>
        <ul id="drawLogList" class="log-list">
            <li class="empty-message">No draws yet.</li>
        </ul>

        <div class="centered-controls-alt">
            <button id="btnResetSession" class="danger">Reset Session</button>
        </div>
    </div>
</div>

<script>
    // --- DATA MODEL & LOGIC (Embedded) ---

    const LOOT_TEMPLATES = {
        'gold_1': { id: 'gold_1', label: '1 Gold', payload: { gold: 1 } },
        'gold_2': { id: 'gold_2', label: '2 Gold', payload: { gold: 2 } },
        'gold_3': { id: 'gold_3', label: '3 Gold', payload: { gold: 3 } },
        'lumber_1': { id: 'lumber_1', label: '1 Lumber', payload: { lumber: 1 } },
        'lumber_2': { id: 'lumber_2', label: '2 Lumber', payload: { lumber: 2 } },
        'metal_1': { id: 'metal_1', label: '1 Metal', payload: { metal: 1 } },
        'metal_2': { id: 'metal_2', label: '2 Metal', payload: { metal: 2 } },
        'hide_1': { id: 'hide_1', label: '1 Hide', payload: { hide: 1 } },
        'hide_2': { id: 'hide_2', label: '2 Hide', payload: { hide: 2 } },
        'arrowvine': { id: 'arrowvine', label: 'Arrowvine', payload: { arrowvine: 1 } },
        'axenut': { id: 'axenut', label: 'Axenut', payload: { axenut: 1 } },
        'corpsecap': { id: 'corpsecap', label: 'Corpsecap', payload: { corpsecap: 1 } },
        'flamefruit': { id: 'flamefruit', label: 'Flamefruit', payload: { flamefruit: 1 } },
        'rockroot': { id: 'rockroot', label: 'Rockroot', payload: { rockroot: 1 } },
        'snowthistle': { id: 'snowthistle', label: 'Snowthistle', payload: { snowthistle: 1 } },
        'random_item': { id: 'random_item', label: 'Random Item', payload: {} }
    };

    // Definitions of the physical supply of cards available to build the deck
    // Only multi-copy resources used for random draws are defined here.
    // Single-card / direct groups (herbs, items, etc.) are handled separately via 'direct' type
    // in BUILDER_GROUPS, so they don't need supply deck entries.
    const SUPPLY_DECK = {
        'money': {
            label: 'Money',
            cards: [
                ...Array(1).fill('gold_1'),
                ...Array(6).fill('gold_2'),
                ...Array(2).fill('gold_3')
            ] // Total 9
        },
        'lumber': {
            label: 'Lumber',
            cards: [
                ...Array(2).fill('lumber_1'),
                ...Array(6).fill('lumber_2')
            ] // Total 8
        },
        'metal': {
            label: 'Metal',
            cards: [
                ...Array(2).fill('metal_1'),
                ...Array(6).fill('metal_2')
            ] // Total 8
        },
        'hide': {
            label: 'Hide',
            cards: [
                ...Array(2).fill('hide_1'),
                ...Array(5).fill('hide_2')
            ] // Total 7
        }
    };

    // UI Groups for the builder
    const BUILDER_GROUPS = [
        { id: 'money', label: 'Money', type: 'random', max: 9 },
        { id: 'lumber', label: 'Lumber', type: 'random', max: 8 },
        { id: 'metal', label: 'Metal', type: 'random', max: 8 },
        { id: 'hide', label: 'Hide', type: 'random', max: 7 },
        { id: 'arrowvine', label: 'Arrowvine', type: 'direct' },
        { id: 'axenut', label: 'Axenut', type: 'direct' },
        { id: 'corpsecap', label: 'Corpsecap', type: 'direct' },
        { id: 'flamefruit', label: 'Flamefruit', type: 'direct' },
        { id: 'rockroot', label: 'Rockroot', type: 'direct' },
        { id: 'snowthistle', label: 'Snowthistle', type: 'direct' },
        { id: 'random_item', label: 'Random Item', type: 'direct' }
    ];

    // Preset for Sample Demo Pool
    const SAMPLE_PRESET = {
        'money': 4,
        'lumber': 2,
        'metal': 2,
        'hide': 2,
        'arrowvine': 1, 'axenut': 1, 'corpsecap': 1,
        'flamefruit': 1, 'rockroot': 1, 'snowthistle': 1,
        'random_item': 1
    };

    class LootLogic {
        constructor() {
            this.composition = {};
            this.pool = [];
            this.log = [];

            // Initialize composition with 0 for all builder groups
            BUILDER_GROUPS.forEach(group => {
                this.composition[group.id] = 0;
            });
        }

        setCount(groupId, count) {
            if (count < 0) return;
            this.composition[groupId] = parseInt(count) || 0;
        }

        getConfiguredSize() {
            return Object.values(this.composition).reduce((sum, c) => sum + c, 0);
        }

        buildPool() {
            this.pool = [];
            this.log = [];
            const warnings = [];

            for (const [groupId, count] of Object.entries(this.composition)) {
                if (count <= 0) continue;

                const groupDef = BUILDER_GROUPS.find(g => g.id === groupId);
                if (!groupDef) continue;

                if (groupDef.type === 'direct') {
                    // Direct mapping: groupId matches a template ID
                    for (let i = 0; i < count; i++) {
                        this.pool.push(groupId);
                    }
                } else if (groupDef.type === 'random') {
                    // Random draw from supply
                    const supply = [...SUPPLY_DECK[groupId].cards]; // copy
                    
                    // Shuffle supply so that any subset or full usage is randomized
                    for (let i = supply.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [supply[i], supply[j]] = [supply[j], supply[i]];
                    }

                    // Shuffle supply
                    for (let i = supply.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [supply[i], supply[j]] = [supply[j], supply[i]];
                    }

                    if (count > supply.length) {
                        showError(`Warning: You requested ${count} ${groupDef.label}, but only ${supply.length} are available. Using all available.`);
                        // Add all available (now shuffled)
                        this.pool.push(...supply);
                    } else {
                        // Take top N from shuffled supply
                        this.pool.push(...supply.slice(0, count));
                    }
                }
            }
            return { success: true, warnings: warnings };
        }

        draw(n) {
            if (n <= 0) {
                return { success: false, error: "Must draw at least 1 token" };
            }
            if (n > this.pool.length) {
                return { success: false, error: `Cannot draw ${n} cards. Only ${this.pool.length} remaining.` };
            }

            const drawnIds = [];
            for (let i = 0; i < n; i++) {
                const index = Math.floor(Math.random() * this.pool.length);
                const [item] = this.pool.splice(index, 1);
                drawnIds.push(item);
            }

            this.log.unshift({
                timestamp: Date.now(),
                draws: drawnIds
            });

            return { success: true, draws: drawnIds };
        }

        getRemainingCount(templateId) {
            return this.pool.filter(id => id === templateId).length;
        }

        getRemainingCounts() {
            // Aggregate counts by display group (family)
            const counts = {};

            // Initialize counts for all builder groups
            BUILDER_GROUPS.forEach(group => {
                counts[group.label] = 0;
            });

            for (const id of this.pool) {
                // Find which group this card belongs to
                // First check if it's a direct match (like herbs)
                let group = BUILDER_GROUPS.find(g => g.id === id);

                if (!group) {
                    // If not direct, check if it belongs to a supply deck (e.g. gold_1 in 'money')
                    const supplyEntry = Object.entries(SUPPLY_DECK).find(([key, val]) => val.cards.includes(id));
                    if (supplyEntry) {
                        const [supplyKey] = supplyEntry;
                        group = BUILDER_GROUPS.find(g => g.id === supplyKey);
                    }
                }

                if (group) {
                    counts[group.label] = (counts[group.label] || 0) + 1;
                } else {
                    // Fallback for unknown items
                    counts[id] = (counts[id] || 0) + 1;
                }
            }
            return counts;
        }

        resetSession() {
            this.pool = [];
            this.log = [];
        }

        clearCounts() {
            Object.keys(this.composition).forEach(id => {
                this.composition[id] = 0;
            });
        }

        applyPreset(preset) {
            this.clearCounts();
            Object.entries(preset).forEach(([id, count]) => {
                if (this.composition.hasOwnProperty(id)) {
                    this.composition[id] = count;
                }
            });
        }
    }

    // --- UI CONTROLLER ---

    const app = new LootLogic();

    // Create a Map for O(1) lookup of BUILDER_GROUPS
    const BUILDER_GROUPS_MAP = new Map(BUILDER_GROUPS.map(g => [String(g.id), g]));

    // DOM Elements
    const builderView = document.getElementById('builderView');
    const activeView = document.getElementById('activeView');
    const templateGrid = document.getElementById('templateGrid');
    const configuredSizeDisplay = document.getElementById('configuredSizeDisplay');
    const remainingCountDisplay = document.getElementById('remainingCountDisplay');
    const statsTableBody = document.getElementById('statsTableBody');
    const drawLogList = document.getElementById('drawLogList');
    // inputTokens removed
    const drawError = document.getElementById('drawError');

    // Initialization
    function init() {
        renderBuilder();
        updateConfiguredSize();

        // Builder Event Listeners
        document.getElementById('btnPresetBlank').addEventListener('click', () => {
            app.clearCounts();
            refreshBuilderInputs();
            updateConfiguredSize();
        });

        document.getElementById('btnPresetSample').addEventListener('click', () => {
            app.applyPreset(SAMPLE_PRESET);
            refreshBuilderInputs();
            updateConfiguredSize();
        });

        document.getElementById('btnBuildPool').addEventListener('click', () => {
            if (app.getConfiguredSize() === 0) {
                alert("Please add at least one card to the pool.");
                return;
            }
            const result = app.buildPool();
            if (result.warnings && result.warnings.length > 0) {
                alert(result.warnings.join('\n'));
            }
            switchToActiveView();
        });

        // Active View Event Listeners
        document.getElementById('btnDraw').addEventListener('click', handleDraw);

        document.getElementById('btnResetSession').addEventListener('click', () => {
            if (confirm("Are you sure you want to reset the session? Current pool and history will be lost.")) {
                app.resetSession();
                // inputTokens reset removed
                switchToBuilderView();
            }
        });
    }

    // Builder Functions
    function renderBuilder() {
        templateGrid.innerHTML = '';
        BUILDER_GROUPS.forEach(group => {
            const div = document.createElement('div');
            div.className = 'template-item';
            
            const labelId = `label_${group.id}`;
            const label = document.createElement('label');
            label.textContent = group.label;
            label.htmlFor = `stepper-${group.id}`;

            // Stepper Control
            const stepperDiv = document.createElement('div');
            stepperDiv.className = 'stepper-control';
            stepperDiv.id = `stepper-${group.id}`;

            const btnDec = document.createElement('button');
            btnDec.type = 'button';
            btnDec.className = 'stepper-btn';
            btnDec.type = 'button';
            btnDec.textContent = '-';
            btnDec.disabled = true; // Initially 0
            btnDec.setAttribute('aria-label', `Decrease ${group.label}`);

            const display = document.createElement('span');
            display.className = 'stepper-value';
            display.textContent = '0';
            display.dataset.id = String(group.id);
            display.setAttribute('role', 'status');
            display.setAttribute('aria-label', `${group.label} count`);
            display.setAttribute('aria-live', 'polite');
            display.setAttribute('tabindex', '0');

            const btnInc = document.createElement('button');
            btnInc.type = 'button';
            btnInc.className = 'stepper-btn';
            btnInc.type = 'button';
            btnInc.textContent = '+';
            btnInc.setAttribute('aria-label', `Increase ${group.label}`);

            // Shared update function for value changes
            const updateValue = (newVal) => {
                display.textContent = newVal;
                updateConfiguredSize();
                btnDec.disabled = (newVal <= 0);
                btnInc.disabled = group.max && newVal >= group.max;
            };

            // Event Handlers
            btnDec.addEventListener('click', () => {
                let currentVal = app.composition[group.id] || 0;
                if (currentVal > 0) {
                    currentVal--;
                    app.setCount(group.id, currentVal);
                    updateValue(currentVal);
                }
            });

            btnInc.addEventListener('click', () => {
                let currentVal = app.composition[group.id] || 0;
                // If there's a max, strictly enforce it for UI
                if (group.max && currentVal >= group.max) {
                    return;
                }

                currentVal++;
                app.setCount(group.id, currentVal);
                updateValue(currentVal);
            });

            // Keyboard support for the stepper value display
            display.addEventListener('keydown', (e) => {
                let currentVal = app.composition[group.id] || 0;
                let newVal = currentVal;

                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!group.max || currentVal < group.max) {
                        newVal = currentVal + 1;
                    }
                } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (currentVal > 0) {
                        newVal = currentVal - 1;
                    }
                }

                if (newVal !== currentVal) {
                    app.setCount(group.id, newVal);
                    updateValue(newVal);
                }
            });

            // Keyboard navigation for display
            display.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!btnInc.disabled) btnInc.click();
                } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (!btnDec.disabled) btnDec.click();
                }
            });

            stepperDiv.appendChild(btnDec);
            stepperDiv.appendChild(display);
            stepperDiv.appendChild(btnInc);

            div.appendChild(label);
            div.appendChild(stepperDiv);
            templateGrid.appendChild(div);
        });
    }

    function refreshBuilderInputs() {
        const displays = templateGrid.querySelectorAll('.stepper-value');

        // Create lookup map to avoid O(n) search in loop
        const groupMap = new Map();
        BUILDER_GROUPS.forEach(g => groupMap.set(String(g.id), g));

        displays.forEach(display => {
            const id = display.dataset.id;
            const newVal = app.composition[id] || 0;
            display.textContent = newVal;

            // Also update button states (disable/enable)
            const parent = display.parentElement;
            if (parent) {
                const btnDec = parent.querySelector('.stepper-btn:first-child');
                const btnInc = parent.querySelector('.stepper-btn:last-child');

                if (btnDec) {
                    btnDec.disabled = (newVal <= 0);
                }

                if (btnInc) {
                    // Check max using Map for O(1) lookup
                    const group = BUILDER_GROUPS_MAP.get(id);
                    if (group && group.max) {
                        btnInc.disabled = (newVal >= group.max);
                    } else {
                        btnInc.disabled = false;
                    }
                }
            }
        });
    }

    function updateConfiguredSize() {
        configuredSizeDisplay.textContent = app.getConfiguredSize();
    }

    // Active View Functions
    function switchToActiveView() {
        builderView.classList.add('hidden');
        activeView.classList.remove('hidden');
        drawError.classList.remove('visible');
        updateActiveDisplay();
    }

    function switchToBuilderView() {
        activeView.classList.add('hidden');
        builderView.classList.remove('hidden');
    }

    function updateActiveDisplay() {
        // Update total remaining
        const total = app.pool.length;
        remainingCountDisplay.textContent = total;

        // Update counts table
        const counts = app.getRemainingCounts();
        statsTableBody.innerHTML = '';

        // Only display loot templates that currently have a remaining count greater than zero.
        Object.entries(counts).forEach(([label, count]) => {
            if (count > 0) {
                const tr = document.createElement('tr');
                const tdLabel = document.createElement('td');
                const tdCount = document.createElement('td');
                
                tdLabel.textContent = label;
                tdCount.textContent = String(count);
                
                tr.appendChild(tdLabel);
                tr.appendChild(tdCount);
                statsTableBody.appendChild(tr);
            }
        });

        if (total === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 2;
            td.className = 'centered-text';
            td.textContent = 'Pool is empty';
            tr.appendChild(td);
            statsTableBody.appendChild(tr);
        }

        // Update Log
        renderLog();

        // Update Draw Button State
        const btnDraw = document.getElementById('btnDraw');
        // Always drawing 1, so simply check if pool is empty
        if (total === 0) {
            btnDraw.disabled = true;
        } else {
            btnDraw.disabled = false;
        }
    }

    function renderLog() {
        drawLogList.innerHTML = '';
        if (app.log.length === 0) {
            const li = document.createElement('li');
            li.className = 'empty-message';
            li.textContent = 'No draws yet.';
            drawLogList.appendChild(li);
            return;
        }

        app.log.forEach(entry => {
            const li = document.createElement('li');
            li.className = 'log-entry';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = new Date(entry.timestamp).toLocaleTimeString();

            const contentSpan = document.createElement('span');
            contentSpan.className = 'log-content';
            contentSpan.textContent = entry.draws.map(id => LOOT_TEMPLATES[id].label).join(', ');

            li.appendChild(timeSpan);
            li.appendChild(contentSpan);
            drawLogList.appendChild(li);
        });
    }

    function handleDraw() {
        // Always draw 1
        const result = app.draw(1);
        if (!result.success) {
            showError(result.error);
        } else {
            drawError.classList.remove('visible');
            updateActiveDisplay();
        }
    }

    function showError(msg) {
        drawError.textContent = msg;
        drawError.classList.add('visible');
        setTimeout(() => {
            drawError.classList.remove('visible');
        }, 3000);
    }

    // Start
    init();

</script>
</body>
</html>
